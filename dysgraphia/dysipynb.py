# -*- coding: utf-8 -*-
"""dysipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16VgFXrLqmqyEFP9jEbWtGEYzCmznRH6v
"""

import cv2
import numpy as np
import sys
import os

# --- ENVIRONMENT DETECTION ---
IN_COLAB = 'google.colab' in sys.modules
if IN_COLAB:
    from google.colab import files
    from google.colab.patches import cv2_imshow
    import matplotlib.pyplot as plt
else:
    from tkinter import Tk, filedialog

# --- OPTIONAL DEPENDENCIES ---
try:
    import pytesseract
    OCR_AVAILABLE = True
except ImportError:
    OCR_AVAILABLE = False
    print("Note: 'pytesseract' not found. OCR legibility check skipped.\n")

def get_image_file():
    """Handles file input for both Colab and Local environments."""
    if IN_COLAB:
        print("\nUpload a handwriting sample.")
        uploaded = files.upload()
        if not uploaded:
            return None
        return list(uploaded.keys())[0]
    else:
        print("\nSelect a handwriting sample from file dialog.")
        try:
            root = Tk()
            root.withdraw()
            root.attributes('-topmost', True)
            fname = filedialog.askopenfilename(
                title="Select Handwriting Sample",
                filetypes=[("Image files", "*.jpg *.jpeg *.png *.bmp *.tiff")]
            )
            root.destroy()
            return fname if fname else None
        except Exception as e:
            print(f"File dialog failed: {e}. Enter path manually.")
            return input("Enter full path to image file: ").strip('"')

# ---------------- EXIT-SAFE IMAGE DISPLAY ----------------
def show_image(title, img):
    if IN_COLAB:
        print(f"--- {title} ---")
        cv2_imshow(img)
    else:
        cv2.imshow(title, img)
        print("Press ESC / q or click the close (X) button to exit.")

        while True:
            # Detect window close (X button)
            if cv2.getWindowProperty(title, cv2.WND_PROP_VISIBLE) < 1:
                break

            key = cv2.waitKey(10)

            # Windows safety
            if key is None or key == -1:
                continue
            key = key & 0xFF

            if key == 27 or key == ord('q'):
                break

        cv2.destroyAllWindows()

def run_dysgraphia_screening_v8():
    print("="*60)
    print("   DYSGRAPHIA SCREENING TOOL (v8.0 - TEXT ONLY)   ")
    print("   - Filters out Line Rules / Margins / Border Artifacts")
    print("   - Adaptive & Weighted Scoring")
    print("="*60)

    # 1. ACQUIRE FILE
    fname = get_image_file()
    if not fname or not os.path.exists(fname):
        print("Error: No valid file selected.")
        return

    # 2. PREPROCESSING
    img_rgb = cv2.imread(fname)
    if img_rgb is None:
        print("Error: Could not read image.")
        return

    target_width = 1000
    h, w = img_rgb.shape[:2]
    scale = target_width / w
    img_rgb = cv2.resize(
        img_rgb,
        (target_width, int(h * scale)),
        interpolation=cv2.INTER_AREA
    )

    img_gray = cv2.cvtColor(img_rgb, cv2.COLOR_BGR2GRAY)
    img_gray_inv = cv2.bitwise_not(img_gray)
    _, thresh = cv2.threshold(
        img_gray_inv, 0, 255,
        cv2.THRESH_BINARY + cv2.THRESH_OTSU
    )

    kernel_small = np.ones((2, 2), np.uint8)
    thresh = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, kernel_small)

    # 3. AUTO-CALIBRATION
    num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(thresh)

    letter_heights = []
    letter_areas = []

    h_img, w_img = thresh.shape
    border_margin = 5

    for i in range(1, num_labels):
        x = stats[i, cv2.CC_STAT_LEFT]
        y = stats[i, cv2.CC_STAT_TOP]
        w_c = stats[i, cv2.CC_STAT_WIDTH]
        h_c = stats[i, cv2.CC_STAT_HEIGHT]
        area = stats[i, cv2.CC_STAT_AREA]

        if x <= border_margin or y <= border_margin or \
           (x + w_c) >= w_img - border_margin or \
           (y + h_c) >= h_img - border_margin:
            continue

        ar = w_c / float(h_c)
        if ar > 5.0 or ar < 0.2:
            continue

        if 4 < h_c < 400 and area > 10:
            letter_heights.append(h_c)
            letter_areas.append(area)

    if not letter_heights:
        print("Error: No valid text detected after filtering.")
        return

    median_h = np.median(letter_heights)
    median_area = np.median(letter_areas)

    print("\n[Auto-Calibration]")
    print(f"Median Letter Height: {median_h:.1f}px (ignoring lines/borders)")

    # 4. SEGMENTATION
    k_w = max(3, int(median_h * 0.8))
    k_h = max(2, int(median_h * 0.25))

    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (k_w, k_h))
    thresh_dilated = cv2.dilate(thresh, kernel, iterations=1)

    contours, _ = cv2.findContours(
        thresh_dilated, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE
    )

    word_boxes = []
    for cnt in contours:
        x, y, w_c, h_c = cv2.boundingRect(cnt)
        if w_c * h_c > median_area * 0.5:
            word_boxes.append({'x': x, 'y': y, 'w': w_c, 'h': h_c})

    # 5. METRICS
    spacings = []
    for i in range(len(word_boxes) - 1):
        d = word_boxes[i + 1]['x'] - (
            word_boxes[i]['x'] + word_boxes[i]['w']
        )
        if d > 0:
            spacings.append(d)

    spacing_cv = np.std(spacings) / np.mean(spacings) if spacings else 0
    size_cv = np.std(letter_heights) / np.mean(letter_heights)

    ocr_score = 100
    if OCR_AVAILABLE:
        try:
            data = pytesseract.image_to_data(
                img_rgb, output_type=pytesseract.Output.DICT
            )
            confs = [float(c) for c in data['conf'] if c != '-1']
            if confs:
                ocr_score = np.mean(confs)
        except:
            pass

    total_risk_score = 0
    if spacing_cv > 0.60:
        total_risk_score += 2.5
    elif spacing_cv > 0.45:
        total_risk_score += 1.0

    if size_cv > 0.30:
        total_risk_score += 2.5
    elif size_cv > 0.20:
        total_risk_score += 1.0

    if ocr_score < 50:
        total_risk_score += 2.0
    elif ocr_score < 70:
        total_risk_score += 1.0

    print("\nTOTAL RISK SCORE:", total_risk_score)

    if total_risk_score >= 5.0:
        verdict = "HIGH RISK"
    elif total_risk_score >= 2.5:
        verdict = "MODERATE RISK"
    else:
        verdict = "LOW RISK"

    print("VERDICT:", verdict)

    # 6. VISUALIZATION
    vis_img = img_rgb.copy()
    for b in word_boxes:
        cv2.rectangle(
            vis_img,
            (b['x'], b['y']),
            (b['x'] + b['w'], b['y'] + b['h']),
            (255, 0, 0),
            2
        )

    show_image("Text-Only Analysis", vis_img)

if __name__ == "__main__":
    run_dysgraphia_screening_v8()
